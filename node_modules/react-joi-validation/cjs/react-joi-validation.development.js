/**
 * ISC License
 *
 * Copyright (c) 2018, Aleck Greenham
 *
 * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var get = _interopDefault(require('lodash.get'));
var set = _interopDefault(require('lodash.set'));
var reduce = _interopDefault(require('lodash.reduce'));
var isPlainObject = _interopDefault(require('lodash.isplainobject'));
var each = _interopDefault(require('lodash.foreach'));
var toPath = _interopDefault(require('lodash.topath'));
var isString = _interopDefault(require('lodash.isstring'));
var deepClone = _interopDefault(require('lodash.clonedeep'));
var isUndefined = _interopDefault(require('lodash.isundefined'));
var unique = _interopDefault(require('lodash.uniq'));
var keys = _interopDefault(require('lodash.keys'));
var map = _interopDefault(require('lodash.map'));
var React = require('react');
var React__default = _interopDefault(React);
var unset = _interopDefault(require('lodash.unset'));
var drop = _interopDefault(require('lodash.drop'));
var has = _interopDefault(require('lodash.has'));
var defaultsDeep = _interopDefault(require('lodash.defaultsdeep'));
var invariant = _interopDefault(require('invariant'));

function emptyFunc () {
  // Noop
}

function arrayFrom (target) {
  if (target) {

    if (Array.isArray(target)) {
      return target;
    } else {
      return [target];
    }
  } else {
    return [];
  }
}

function pickDeep (source, paths) {
  return reduce(paths, function (memo, path) {

    var sourceValue = get(source, path);
    set(memo, path, sourceValue);

    return memo;
  }, {});
}

function pickOutermost(target) {
  var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];


  if (isPlainObject(target)) {

    each(target, function (subValue) {
      pickOutermost(subValue, list);
    });
  } else if (Array.isArray(target)) {

    each(target, function (element) {
      pickOutermost(element, list);
    });
  } else {

    if (target) {
      list.push(target);
    }
  }

  return list;
}

function isNumberString(string) {
  return !isNaN(+string);
}

var Wildcard = '*';

function extendAnyTouchedAncestors(target, path) {
  var pathSegments = toPath(path);

  var ancestorPathSegments = touchedAncestorPathSegments(target, pathSegments);

  if (ancestorPathSegments) {

    var newPathNode = function () {
      var nextPathSegment = pathSegments[ancestorPathSegments.length];

      if (isNumberString(nextPathSegment)) {
        return [];
      } else {
        return {};
      }
    }();

    newPathNode[Wildcard] = Wildcard;

    set(target, ancestorPathSegments, newPathNode);
  }
}

function touchedAncestorPathSegments(target, pathSegments) {

  var index = 0;

  while (index <= pathSegments.length) {
    var thisPathSegments = pathSegments.slice(0, index + 1);

    var thisValue = get(target, thisPathSegments);

    if (isString(thisValue)) {
      return thisPathSegments;
    }

    index++;
  }
}

function mergeValidatedValuePaths(newTouchedValuePaths, previouslyTouchedValues) {

  return reduce(newTouchedValuePaths, function (updatedTouchedValues, path) {

    if (path !== Wildcard) {

      extendAnyTouchedAncestors(updatedTouchedValues, path);

      set(updatedTouchedValues, path, path);
    }

    return updatedTouchedValues;
  }, deepClone(previouslyTouchedValues));
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

function valueAlreadyTouched(value) {
  return isString(value) || value && value[Wildcard];
}

function valuesWithDefaultsAndExemptions(_ref) {
  var _ref$deepMergeExempti = _ref.deepMergeExemptions,
      deepMergeExemptions = _ref$deepMergeExempti === undefined ? {} : _ref$deepMergeExempti,
      overrides = _ref.overrides,
      defaultValue = _ref.defaultValue;


  if (valueAlreadyTouched(deepMergeExemptions) || isUndefined(defaultValue)) {

    return overrides;
  } else {

    if (isUndefined(overrides)) {

      return defaultValue;
    } else {

      if (isPlainObject(overrides)) {

        var unionOfObjectKeys = unique([].concat(toConsumableArray(keys(defaultValue)), toConsumableArray(keys(overrides))));

        return reduce(unionOfObjectKeys, function (memo, key) {

          if (valueAlreadyTouched(deepMergeExemptions[key])) {

            memo[key] = overrides[key];
          } else {

            memo[key] = valuesWithDefaultsAndExemptions({
              defaultValue: defaultValue[key],
              overrides: overrides[key],
              deepMergeExemptions: deepMergeExemptions[key]
            });
          }

          return memo;
        }, {});
      } else if (Array.isArray(overrides)) {

        var overridesIsLongerThanDefault = overrides.length > defaultValue.length;

        if (overridesIsLongerThanDefault) {

          return map(overrides, function (overrideElement, index) {

            if (valueAlreadyTouched(deepMergeExemptions[index])) {

              return overrideElement;
            } else {

              return valuesWithDefaultsAndExemptions({
                defaultValue: defaultValue[index],
                overrides: overrideElement,
                deepMergeExemptions: deepMergeExemptions[index]
              });
            }
          });
        } else {

          return map(defaultValue, function (defaultValueElement, index) {

            if (valueAlreadyTouched(deepMergeExemptions[index])) {

              return overrides[index];
            } else {

              return valuesWithDefaultsAndExemptions({
                defaultValue: defaultValueElement,
                overrides: overrides[index],
                deepMergeExemptions: deepMergeExemptions[index]
              });
            }
          });
        }
      } else {

        return overrides;
      }
    }
  }
}

var Joi = void 0;

var DEFAULT_STATE = {
  errors: {},
  values: {},
  touchedValues: {},
  validatedValues: {},
  changingValues: [],

  validateAllValues: false
};

/**
 * Takes arguments that resemble those commonly passed to event handlers and attempts
 * to guess what the desired event value should be. This function is the default used
 * by all *Handler methods to extract values from events so that they can be set and
 * validated.
 * @param {*} event The first argument, assumed to be an event object but does not need
*         to be.
 * @param {*} value The second argument, assumed to be the value of the event, but
 *        does not need to be.
 * @returns {*} The assumed event value
 */
function guessCorrectValue(event, value) {

  /**
   * Inspect the callback arguments when the handler is called
   */
  var eventTargetValue = get(event, 'target.value');

  if (eventTargetValue) {
    // Use value from event object
    return eventTargetValue;
  } else {
    // Use value provided as second argument
    return value;
  }
}

/**
 * Returns the target value of an event that is passed to it
 * @param {Event} event Event object for which the target value will be returned
 * @returns {*} The target value of the event passed as the first argument
 */
function useEventTargetValue(event) {
  return get(event, 'target.value');
}

/**
 * Returns the first argument. Used for adapting event handlers that return the event
 * value as the first argument.
 * @param {*} value First argument
 * @returns {*} The value of the first argument
 */
function useFirstArgument(value) {
  return value;
}

/**
 * Returns the second argument. Used for adapting event handlers that return the event
 * value as the second argument.
 * @param {*} arg1 The first argument
 * @param {*} value Second argument
 * @returns {*} The value of the second argument
 */
function useSecondArgument(arg1, value) {
  return value;
}

/**
 * Returns the third argument. Used for adapting event handlers that return the event
 * value as the third argument.
 * @param {*} arg1 The first argument
 * @param {*} arg2 The second argument
 * @param {*} value Third argument
 * @returns {*} The value of the third argument
 */
function useThirdArgument(arg1, arg2, value) {
  return value;
}

var defaultChangeHandlerStrategy = guessCorrectValue;

/**
 * Returns a validator component that wraps a validated component and provides
 * methods for updating and validating the validator component's state via the
 * validated component's props
 *
 * @param {Component} ValidatedComponent Component to wrap and provide the methods
 *        for updating and validating values as props
 * @param {Object.<String,*>} options A configuration hash
 * @param {Joi|Object?} options.joiSchema A Joi schema that, if provided, is used
 *        to validate the values stored in the validator component's state every time
 *        one of the validation methods are called.
 * @param {Object?} options.joiOptions Options that are passed to Joi on every
 *        validation attempt. See the documentation for the version of Joi that you
 *        are using.
 * @param {Function|Array.<Function>?} options.validator A function or array of
 *        functions to use to validate the values stored in the validator component's
 *        state every time one of the validate methods are called. Can be used in
 *        conjunction with the joiSchema option, or without it. If both are specified,
 *        the joiSchema validation is performed first and then the validators are
 *        called in the order that they appear in the array.
 * @param {String|Array.<String>?} options.only Path or paths to the part of the props
 *        object passed to the validator (and passed through to the validated
 *        object) that should be validated against the joi schema. Useful if you
 *        want to validate only part of the props.
 * @param {String|Array.<String>?} pseudoValues List of paths to values that aren't
 *        actually in the props passed to the validator component and are never set
 *        by the validated component, but are accessible to attach validation errors
 *        to, in validator functions.
 * @param {String="errors"} externalErrorsPath Path to the attribute on props that
 *        stores the errors object of any validation performed outside of the
 *        validator component. These errors are merged into those set by the validator
 *        component.
 * @param {Function?} changeHandlerStrategy The default change handler strategy to
 *        use in the validator component. i.e. The default function that should be used
 *        to map the arguments of event handlers to the validation handlers', provided
 *        by the validator component. If unspecified, the default set at the package
 *        level using setChangeHandlerStrategy() is used, or the guessCorrectValue
 *        function if none has been otherwise specified.
 * @returns {ValidatorComponent} The validator component, that wrapping the validated
 *        component.
 */

var ReactJoiValidation = function ReactJoiValidation(ValidatedComponent, _ref) {
  var joiSchema = _ref.joiSchema,
      joiOptions = _ref.joiOptions,
      validator = _ref.validator,
      only = _ref.only,
      _ref$pseudoValues = _ref.pseudoValues,
      pseudoValues = _ref$pseudoValues === undefined ? [] : _ref$pseudoValues,
      externalErrorsPath = _ref.externalErrorsPath,
      changeHandlerStrategy = _ref.changeHandlerStrategy;

  function usingSingularValidationScope() {
    return isString(only);
  }

  function wrapObject(object) {
    if (usingSingularValidationScope()) {
      return set({}, only, object);
    } else {
      return object;
    }
  }

  function unwrapObject(object) {
    if (usingSingularValidationScope()) {
      return get(object, only);
    } else {
      return object;
    }
  }

  function pickErrors(errors, touchedValues) {

    var listOfTouchedValues = pickOutermost(touchedValues);

    var valuesToPick = [].concat(toConsumableArray(listOfTouchedValues), toConsumableArray(arrayFrom(pseudoValues)));

    return reduce(valuesToPick, function (activeErrors, valuePath) {

      if (!valuePath.endsWith(Wildcard)) {
        var error = get(errors, valuePath);

        if (error) {
          set(activeErrors, valuePath, error);
        }
      }

      return activeErrors;
    }, {});
  }

  function getValueToUse(options, firstArg, secondArg, thirdArg) {
    if (has(options, 'value')) {

      /**
       * Allow setting a fixed value at the time of binding the change
       * handler and ignore whatever value is passed when the handler
       * is called
       */
      return options.value;
    } else {
      return (options.strategy || changeHandlerStrategy || defaultChangeHandlerStrategy)(firstArg, secondArg, thirdArg);
    }
  }

  /**
   * @class ValidatorComponent Component class that renders its children with props
   * that contain functions for updating and validating the values stored in the
   * validator component's state.
   */

  var ValidatorComponent = function (_Component) {
    inherits(ValidatorComponent, _Component);

    /**
     * Creates a new instance of a ValidatorComponent, binds all validation and
     * update methods to that instance, and sets its default state.
     *
     * @param {Object.<*,*>} props Props that are passed through this
     *        component to the validated component. All or part of these values
     *        determine the initial values in the component's state, depending
     *        on ReactJoiValidation's only option.
     * @param {Object.<*,*>} context Context object for this component and the
     *        validated component
     *
     * @see ReactJoiValidation
     */
    function ValidatorComponent(props, context) {
      classCallCheck(this, ValidatorComponent);

      var _this = possibleConstructorReturn(this, (ValidatorComponent.__proto__ || Object.getPrototypeOf(ValidatorComponent)).call(this, props, context));

      _this.changeHandler = _this.changeHandler.bind(_this);
      _this.changesHandler = _this.changesHandler.bind(_this);
      _this.changeValue = _this.changeValue.bind(_this);
      _this.changeValues = _this.changeValues.bind(_this);

      _this.pushHandler = _this.pushHandler.bind(_this);
      _this.pushValue = _this.pushValue.bind(_this);
      _this.togglePushHandler = _this.togglePushHandler.bind(_this);
      _this.togglePushValue = _this.togglePushValue.bind(_this);

      _this.unshiftHandler = _this.unshiftHandler.bind(_this);
      _this.unshiftValue = _this.unshiftValue.bind(_this);
      _this.toggleUnshiftHandler = _this.toggleUnshiftHandler.bind(_this);
      _this.toggleUnshiftValue = _this.toggleUnshiftValue.bind(_this);

      _this.pullHandler = _this.pullHandler.bind(_this);
      _this.pullValue = _this.pullValue.bind(_this);

      _this.validateHandler = _this.validateHandler.bind(_this);
      _this.validate = _this.validate.bind(_this);

      _this.validateAll = _this.validateAll.bind(_this);
      _this.validateAllHandler = _this.validateAllHandler.bind(_this);

      _this.clearValidation = _this.clearValidation.bind(_this);
      _this.clearValidationState = _this.clearValidationState.bind(_this);
      _this.clearValidationAndResetValues = _this.clearValidationAndResetValues.bind(_this);
      _this.clearTouchedValues = _this.clearTouchedValues.bind(_this);

      _this.state = _extends({}, DEFAULT_STATE);
      return _this;
    }

    /**
     * Renders the validated component with all of the functions for updating and
     * validating the validator component's state, as props. All props passed to the
     * validator component are also passed through to the validated component.
     *
     * @returns {Component} The validated component, with the update and validation
     *          props provided
     */


    createClass(ValidatorComponent, [{
      key: 'render',
      value: function render() {
        var _state = this.state,
            touchedValues = _state.touchedValues,
            values = _state.values;


        return React__default.createElement(ValidatedComponent, _extends({}, this.props, this._valuesWithDefaults({ values: values, touchedValues: touchedValues }), {

          errors: this._getActiveErrors(),

          changeHandler: this.changeHandler,
          changesHandler: this.changesHandler,
          changeValue: this.changeValue,
          changeValues: this.changeValues,

          pushHandler: this.pushHandler,
          pushValue: this.pushValue,
          togglePushHandler: this.togglePushHandler,
          togglePushValue: this.togglePushValue,

          unshiftHandler: this.unshiftHandler,
          unshiftValue: this.unshiftValue,
          toggleUnshiftHandler: this.toggleUnshiftHandler,
          toggleUnshiftValue: this.toggleUnshiftValue,

          pullHandler: this.pullHandler,
          pullValue: this.pullValue,

          validateHandler: this.validateHandler,
          validate: this.validate,

          validateAllHandler: this.validateAllHandler,
          validateAll: this.validateAll,

          clearValidationState: this.clearValidationState,
          clearValidation: this.clearValidation,
          clearValidationAndResetValues: this.clearValidationAndResetValues,
          clearValidationTouchedValues: this.clearTouchedValues
        }));
      }

      /**
       * Returns a function that, when called, pushes a value onto the end of an array
       * stored in the validator component's state
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should push new values onto.
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {Boolean=true} options.allowDuplicates Whether or not to push a value
       *        onto the array if it already appears in that array.
       * @param {*?} options.value The value to push onto the array when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used as the new value. Useful for standardising
       *        different event handler argument signatures. The package exports some
       *        common strategy functions for you to use, but it is possible to use
       *        any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will update the array
       *        at valuePath, according to the options provided
       *
       * @example
       * render() {
       *   const { pushHandler, cities } = this.props;
       *
       *   return(
       *     ["Paris", "New York City", "London"].map((city) => {
       *       return(
       *         <input type='button' label={ "Add " + city } onClick={ pushHandler('cities') } />
       *       );
       *     }
       *   );
       * }
       *
       */

    }, {
      key: 'pushHandler',
      value: function pushHandler(valuePath) {
        var _this2 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this2.pushValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * Immediately pushes a value onto the end of an array
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should push new values onto.
       * @param {*} value The value to push onto the end of the array
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean=true} options.allowDuplicates Whether or not to push a value
       *        onto the array if it already appears in that array.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @example
       * handleAddCity(city) {
       *    const { pushValue, cities } = this.props;
       *
       *    if (cities.indexOf(city) === -1 ) {
       *       pushValue('cities', city);
       *    }
       * }
       *
       */

    }, {
      key: 'pushValue',
      value: function pushValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        this._addValue('end', valuePath, value, options);
      }

      /**
       * Returns a function that, when called, pushes a value onto the end of an array
       * if that value is not already in the array, otherwise it removes it. i.e. it
       * toggles that value's inclusion in the array.
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should push new values onto.
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {*?} options.value The value to toggle in the array when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used as the new value. Useful for standardising
       *        different event handler argument signatures. The package exports some
       *        common strategy functions for you to use, but it is possible to use
       *        any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will toggle the
       *        inclusion or exclusion of a value in the array at at valuePath
       *
       * @example
       * render() {
       *   const { togglePushHandler, cities } = this.props;
       *
       *   return(
       *     ["Paris", "New York City", "London"].map((city) => {
       *       return(
       *         <label>
       *            <input type='checkbox' onClick={ togglePushHandler('cities') } />
       *            { city }
       *         </label>
       *       );
       *     }
       *   );
       * }
       *
       */

    }, {
      key: 'togglePushHandler',
      value: function togglePushHandler(valuePath) {
        var _this3 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this3.togglePushValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * Immediately pushes a value onto the end of an array if that value is not
       * already in the array, otherwise it removes it. i.e. it toggles that value's
       * inclusion in the array.
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should toggle the value.
       * @param {*} value The value to toggle the inclusion or exclusion in array
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @example
       * render() {
       *   return(
       *     ["Paris", "New York City", "London"].map((city) => {
       *       return(
       *         <label>
       *             <input type='checkbox' onClick={ this.handleToggleCity('cities') } />
       *             { city }
       *         </label>
       *       );
       *     }
       *   );
       * }
       *
       * handleToggleCity(city) {
       *   const { togglePushHandler, cities } = this.props;
       *
       *   togglePushHandler('cities', city);
       * }
       *
       */

    }, {
      key: 'togglePushValue',
      value: function togglePushValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var currentValue = this._getCurrentValue(valuePath) || [];

        if (currentValue.indexOf(value) === -1) {
          this._addValue('end', valuePath, value, _extends({}, options, { allowDuplicates: false }));
        } else {
          this.pullValue(valuePath, value, _extends({}, options, { removeAllInstances: true }));
        }
      }

      /**
       * Similar to pushValueHandler, but the returned function, when called,
       * adds a value to the beginning of an array, instead
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should add a value to the beginning
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {Boolean=true} options.allowDuplicates Whether or not to unshift a value
       *        onto the array if it already appears in that array.
       * @param {*?} options.value The value to unshift onto the array when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used as the new value. Useful for standardising
       *        different event handler argument signatures. The package exports some
       *        common strategy functions for you to use, but it is possible to use
       *        any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will update the array
       *        at valuePath, according to the options provided
       *
       * @see pushValueHandler
       */

    }, {
      key: 'unshiftHandler',
      value: function unshiftHandler(valuePath) {
        var _this4 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this4.unshiftValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * Similar to pushValue, but immediately adds a value to the beginning of an array
       * instead
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should add a new values to the beginning.
       * @param {*} value The value to add to the start of the array
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean=true} options.allowDuplicates Whether or not to unshift a value
       *        onto the array if it already appears in that array.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @see pushValue
       */

    }, {
      key: 'unshiftValue',
      value: function unshiftValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        this._addValue('start', valuePath, value, options);
      }

      /**
       * Returns a function that, when called, adds a value to the beginning of an array
       * if that value is not already in the array, otherwise it removes it. i.e. it
       * toggles that value's inclusion in the array.
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should add new value to the start.
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {*?} options.value The value to toggle in the array when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used as the new value. Useful for standardising
       *        different event handler argument signatures. The package exports some
       *        common strategy functions for you to use, but it is possible to use
       *        any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will toggle the
       *        inclusion or exclusion of a value in the array at at valuePath
       *
       * @see togglePushHandler
       */

    }, {
      key: 'toggleUnshiftHandler',
      value: function toggleUnshiftHandler(valuePath) {
        var _this5 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this5.toggleUnshiftValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * Immediately pushes a value to the beginning of an array if that value is not
       * already in the array, otherwise it removes it. i.e. it toggles that value's
       * inclusion in the array.
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should toggle the value.
       * @param {*} value The value to toggle the inclusion or exclusion in array
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @see togglePushValue
       */

    }, {
      key: 'toggleUnshiftValue',
      value: function toggleUnshiftValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var currentValue = this._getCurrentValue(valuePath) || [];

        if (currentValue.indexOf(value) === -1) {
          this._addValue('start', valuePath, value, _extends({}, options, { allowDuplicates: false }));
        } else {
          this.pullValue(valuePath, value, _extends({}, options, { removeAllInstances: true }));
        }
      }

      /**
       * The opposite of pushHandler and unshiftHandler; returns a function that,
       * when called, will remove one or more instances of a value from an array.
       *
       * The default behaviour is to remove only the first instance of the specified
       * value from the array. i.e. the instance of the value with the lowest index.
       *
       * @param {String} valuePath A path pointing to the array value, for which the
       *        function should remove the value.
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {*?} options.value The value to remove from the array when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Number} options.index If specified, the element at the corresponding
       *        index position will be removed, regardless of the value passed to the
       *        function.
       * @param {Boolean=false} options.removeAllInstances If true, all instances of
       *        the specified value are removed from the array - not just the first one.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used the value to remove from the array. Useful
       *        for standardising different event handler argument signatures. The
       *        package exports some common strategy functions for you to use, but
       *        it is possible to use any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will remove the value
       *        from the array at valuePath, according to the options provide
       *
       * @example
       * render() {
       *   const { pullHandler, cities } = this.props;
       *
       *   return(
       *     cities.map((city, index) => {
       *       return(
       *         <input type='button' label={ "Remove " + city } onClick={ pullHandler('cities', { removeAllInstances: true }) } />
       *       );
       *     }
       *   );
       * }
       */

    }, {
      key: 'pullHandler',
      value: function pullHandler(valuePath) {
        var _this6 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this6.pullValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * The opposite of pushValue and unshiftValue; immediately removes a value from
       * an array.
       *
       * The default behaviour is to remove only the first instance of the specified
       * value from the array. i.e. the instance of the value with the lowest index.
       *
       * @param {String} valuePath A path pointing to the array, from which the
       *        function should remove the specified value
       * @param {*} value The value to remove from the array
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Number} options.index If specified, the element at the corresponding
       *        index position will be removed, regardless of the value passed to the
       *        function.
       * @param {Boolean=false} options.removeAllInstances If true, all instances of
       *        the specified value are removed from the array - not just the first one.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       *
       * @see pushValue
       *
       * @example
       * render() {
       *   const { cities } = this.props;
       *
       *   return(
       *     cities.map((city, index) => {
       *       return(
       *         <input type='button' label={ "Remove " + city } onClick={ this.handleRemoveCity } />
       *       );
       *     }
       *   );
       * }
       *
       * handleRemoveCity(city) {
       *    const { pullValue, cities, user } = this.props;
       *
       *    if (user.isAdmin) {
       *       pullValue('cities', city);
       *    }
       * }
       */

    }, {
      key: 'pullValue',
      value: function pullValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var currentValue = this._getCurrentValue(valuePath) || [];

        var finalValue = function () {
          if (options.removeAllInstances) {
            return currentValue.reduce(function (memo, element) {
              if (element !== value) {
                memo.push(element);
              }

              return memo;
            }, []);
          } else {
            invariant(!has(options, 'index') || typeof options.index === 'number', 'pullValue\'s options.index must be a number; Received ' + options.index + ' instead');

            var index = has(options, 'index') ? options.index : currentValue.indexOf(value);

            if (index === -1) {
              return currentValue;
            } else {
              return [].concat(toConsumableArray(currentValue.slice(0, index)), toConsumableArray(currentValue.slice(index + 1)));
            }
          }
        }();

        this.changeValue(valuePath, finalValue, options);
      }

      /**
       * Returns a function that, when called, updates the specified attribute with
       * a new value
       *
       * @param {String} valuePath A path pointing to the attribute to update
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {*?} options.value The new value to set when the function
       *        is called. If not provided, the value will be determined by the
       *        arguments passed to the function when it is called.
       * @param {Function=guessCorrectValue} options.strategy A function that takes
       *        the arguments passed to the function returned by this method, and returns
       *        which one should be used as the new value. Useful for standardising
       *        different event handler argument signatures. The package exports some
       *        common strategy functions for you to use, but it is possible to use
       *        any arbitrary function you like.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will update the
       *        attribute at valuePath, according to the options provided
       *
       * @example
       * const { user: { username }, changeHandler } = this.props;
       *
       *  return(
       *    <div>
       *      <input value={username} onChange={changeHandler('username')} />
       *    </div>
       *  )
       */

    }, {
      key: 'changeHandler',
      value: function changeHandler(valuePath) {
        var _this7 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function (firstArg, secondArg, thirdArg) {
          _this7.changeValue(valuePath, getValueToUse(options, firstArg, secondArg, thirdArg), options);
        };
      }

      /**
       * Updates an attribute with a new value
       *
       * @param {String} valuePath A path pointing to the attribute to update
       * @param {*} value The new value to update the attribute to.
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @example
       * render() {
       *   const { user: { username } } = this.props;
       *
       *   return(
       *     <div>
       *       <input value={username} onChange={this.handleUsernameChange} />
       *     </div>
       *   )
       * }
       *
       * handleUsernameChange(event, newUsername){
       *   const { changeValue } = this.props;
       *
       *   // custom code here
       *   changeValue('username', newUsername)
       * }
       */

    }, {
      key: 'changeValue',
      value: function changeValue(valuePath, value) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        invariant(!Array.isArray(valuePath), 'Value path passed to changeValue was an array. If you want to change multiple values at once, use `changeValues` (pluralized) instead.');

        this.changeValues([[valuePath, value]], options);
      }

      /**
       * Returns a function that, when called, updates multiple attributes with new values
       *
       * @param {Array.<Array.<String|*>>} changes An array of path and new value tuples
       * @param {Object<String,*>?} options A hash of options that configure how the
       *        returned function behaves.
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       * @returns {function(*=, *=, *=)} Function that when called, will update the
       *        attributes with the value specified in the changes list
       *
       * @example
       * return(
       *  <button onChange={changesHandler([['username', ''], ['password', '']])}   >
       *    Clear
       *  </button>
       * )
       */

    }, {
      key: 'changesHandler',
      value: function changesHandler(changes) {
        var _this8 = this;

        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        return function () {
          _this8.changeValues(changes, options);
        };
      }

      /**
       * Updates multiple attributes with new values
       *
       * @param {Array.<Array.<String|*>>} changes An array of path and new value tuples
       * @param {Object<String,*>?} options A hash of configuration options
       * @param {Boolean|String|Array.<String>?} options.validate Whether to validate
       *        the value once it has been set. If true, then the value is validated
       *        after it has been set. If set to a string, the value at the path pointed
       *        to by the string is validated instead of the value being set. If set
       *        to an array of strings, each of the values pointed to by the path in
       *        each string is validated instead of the value being set.
       * @param {Function?} options.callback A function to call once the value has been
       *        set and any validation has been completed.
       *
       * @example
       * render() {
       *   return(
       *     <div>
       *       <button onChange={this.handleClearValues} >
       *         Clear
       *       </button>
       *     </div>
       *   )
       * }
       *
       * handleClearValues(event){
       *   const { changeValues } = this.props;
       *
       *   // custom code here
       *   changeValues([ ['username', ''], ['password', ''] ])
       * }
       */

    }, {
      key: 'changeValues',
      value: function changeValues(changes) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$validate = _ref2.validate,
            validate = _ref2$validate === undefined ? false : _ref2$validate,
            _ref2$callback = _ref2.callback,
            callback = _ref2$callback === undefined ? emptyFunc : _ref2$callback;

        invariant(Array.isArray(changes), 'Changes must be an array of path-value pairs');

        if (validate) {

          var validatePaths = function () {
            if (validate === true) {
              return map(changes, function (_ref3) {
                var _ref4 = slicedToArray(_ref3, 1),
                    valuePath = _ref4[0];

                return valuePath;
              });
            } else {
              return validate;
            }
          }();

          var nextState = this._newState({ validatePaths: validatePaths, changes: changes });

          this._validate(nextState, callback);
        } else {
          var _nextState = this._newState({ changes: changes });

          this.setState(_nextState);
        }
      }

      /**
       * Returns a function that, when called, validates all values currently in the
       * validation component's state (including values set by defaultProps and passed
       * in as props).
       *
       * @param {Function?} callback Function to call once the validation has been
       *        completed and any error messages set.
       * @returns {function()} Function that, when called, will validate all values
       *
       * @example
       * render() {
       *   const { user: { username }, changeHandler, validateAllHandler } = this.props;
       *
       *   return(
       *     <div>
       *       <input value={username}
       *         onChange={changeHandler('username')}
       *       />
       *
       *       <input type="submit" onClick={validateAllHandler(this.handleValidation)} />
       *     </div>
       *   )
       * }
       *
       * handleValidation(){
       *   const { errors } = this.props;
       *
       *   if (!any(errors)) {
       *     // navigate away
       *   }
       * }
       */

    }, {
      key: 'validateAllHandler',
      value: function validateAllHandler() {
        var _this9 = this;

        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyFunc;


        return function () {
          _this9.validateAll(callback);
        };
      }

      /**
       * Validates all values currently in the validation component's state
       * (including values set by defaultProps and passed in as props).
       *
       * @param {Function?} callback Function to call once the validation has been
       *        completed and any error messages set.
       *
       * @example
       * render() {
       *   const { user: { username }, changeHandler } = this.props;
       *
       *   return(
       *     <div>
       *       <input value={username}
       *         onChange={changeHandler('username')}
       *       />
       *
       *       <input type="submit" onClick={this.handleValidation} />
       *     </div>
       *   )
       * }
       *
       * handleValidation(){
       *   const { validateAll } = this.props;
       *
       *   // custom code here
       *
       *   validateAll(() => {
       *     const { errors } = this.props;
       *
       *     if (!any(errors)) {
       *       // navigate away
       *     }
       *   });
       * }
       */

    }, {
      key: 'validateAll',
      value: function validateAll(callback) {
        this._validate(_extends({}, this.state, { validateAllValues: true }), callback);
      }

      /**
       * Returns a function that, when called, validates some of the values currently
       * in the validation component's state (including values set by defaultProps
       * and passed in as props).
       *
       * @param {String|Array.<String>} validatePaths List of paths to values that will
       *        be validated when the returned function is called
       * @param {Function?} callback Function to call once the validation has been
       *        completed and any error messages set.
       * @returns {function()} Function that, when called, will validate the specified
       *        values
       *
       * @example
       * const { address: { country, postcode }, changeHandler, validateHandler } = this.props;
       *
       *     return(
       *      <div>
       *        <input value={postcode}
       *            onChange={changeHandler('postcode')}
       *        />
       *
       *        <input value={country}
       *            onChange={changeHandler('country')}
       *            onBlur={validateHandler(['postcode','country'])}
       *        />
       *      </div>
       *     )
       */

    }, {
      key: 'validateHandler',
      value: function validateHandler(validatePaths) {
        var _this10 = this;

        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyFunc();


        return function () {
          _this10.validate(validatePaths, callback);
        };
      }

      /**
       * Validates some of the values currently in the validation component's state
       * (including values set by defaultProps and passed in as props).
       *
       * @param {String|Array.<String>} validatePaths List of paths to values that will
       *        be validated when the returned function is called
       * @param {Function?} afterValidationCallback Function to call once the
       *        validation has been completed and any error messages set.
       *
       * @example
       * render() {
       *   const { user: { username }, changeHandler } = this.props;
       *
       *   return(
       *     <div>
       *       <input value={username}
       *         onChange={changeHandler('username')}
       *         onBlur={this.handleUsernameValidation}
       *       />
       *     </div>
       *   )
       * }
       *
       * handleUsernameValidation(event){
       *   const { validate } = this.props;
       *
       *   // custom code here
       *
       *   validate('username')
       * }
       */

    }, {
      key: 'validate',
      value: function validate(validatePaths) {
        var afterValidationCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyFunc;

        this._validate(this._newState({ validatePaths: validatePaths }), afterValidationCallback);
      }

      /**
       * Clears the validation state and resets values for some or all of the values
       * being handled by the validator component.
       *
       * @param {String|Array.<String>?} paths A path, or a list of paths for which any
       *      errors or values, should be reset to the default. If not provided, all values
       *      and errors are reset to their default.
       *
       * @deprecated since v1.2.0. Use clearValidationAndResetValues(), instead
       */

    }, {
      key: 'clearValidationState',
      value: function clearValidationState(paths) {
        console.warn('Deprecation Warning: clearValidationState is deprecated. Please use clearValidationAndResetValues() instead.');

        this.clearValidationAndResetValues(paths);
      }

      /**
       * Clears the validation state and resets values for some or all of the values
       * being handled by the validator component.
       *
       * @param {String|Array.<String>?} paths A path, or a list of paths for which any
       *      errors or values, should be reset to the default. If not provided, all values
       *      and errors are reset to their default.
       *
       * @example
       * handleValidation(){
       *   const { validateAll } = this.props;
       *
       *   // custom code here
       *
       *   validateAll(() => {
       *     const { errors, clearValidationAndResetValues } = this.props;
       *
       *     if (!any(errors)) {
       *       // send to your store or server
       *
       *       this.clearValidationAndResetValues()
       *     }
       *   });
       * }
       */

    }, {
      key: 'clearValidationAndResetValues',
      value: function clearValidationAndResetValues(paths) {
        if (paths) {
          var _state2 = this.state,
              touchedValues = _state2.touchedValues,
              validatedValues = _state2.validatedValues,
              values = _state2.values;


          var pathList = arrayFrom(paths);
          var newTouchedValues = deepClone(touchedValues);
          var newValidatedValues = deepClone(validatedValues);
          var newValues = deepClone(values);

          each(pathList, function (path) {
            unset(newTouchedValues, path);
            unset(newValidatedValues, path);
            unset(newValues, path);
          });

          this.setState({
            touchedValues: newTouchedValues,
            validatedValues: newValidatedValues,
            values: newValues
          });
        } else {
          this.setState(_extends({}, DEFAULT_STATE));
        }
      }

      /**
       * Clears the validation state for some or all of the values being handled by
       * the validator component. The actual values are NOT reset.
       *
       * @param {String|Array.<String>?} paths A path, or a list of paths for which any
       *      values should be reset to the default. If not provided, all values
       *      and errors are reset to their default.
       *
       * @example
       * handleValidation() {
       *   const { clearValidation, overrideValidation } = this.props;
       *
       *   if (overrideValidation) {
       *     clearValidation(); // or clearValidation('user.username')
       *   }
       * }
       */

    }, {
      key: 'clearValidation',
      value: function clearValidation(paths) {

        if (paths) {
          var validatedValues = this.state.validatedValues;

          var newValidatedValues = deepClone(validatedValues);

          var pathList = arrayFrom(paths);

          each(pathList, function (path) {
            unset(newValidatedValues, path);
          });

          this.setState({
            validatedValues: newValidatedValues,
            validateAllValues: false
          });
        } else {

          this.setState({
            validatedValues: deepClone(DEFAULT_STATE.validatedValues),
            validateAllValues: false
          });
        }
      }

      /**
       * Clears the record of which values have been touched, i.e. the values that
       * the validated component has updated or validated using any of the functions the
       * validator component provides
       */

    }, {
      key: 'clearTouchedValues',
      value: function clearTouchedValues() {
        this.setState({
          touchedValues: {},
          validateAllValues: false
        });
      }
    }, {
      key: '_addValue',
      value: function _addValue(position, valuePath, value, options) {
        var currentValue = this._getCurrentValue(valuePath) || [];

        var newValue = function () {
          if (options.allowDuplicates === false && currentValue.indexOf(value) !== -1) {
            return currentValue;
          }

          if (position === 'start') {
            return [value].concat(toConsumableArray(currentValue));
          } else {
            return [].concat(toConsumableArray(currentValue), [value]);
          }
        }();

        this.changeValue(valuePath, newValue, options);
      }
    }, {
      key: '_newState',
      value: function _newState(_ref5) {
        var validatePaths = _ref5.validatePaths,
            changes = _ref5.changes;
        var _state3 = this.state,
            validatedValues = _state3.validatedValues,
            touchedValues = _state3.touchedValues,
            values = _state3.values;


        var newValues = deepClone(values);
        var newTouchedValues = deepClone(touchedValues);
        var changingValues = [];

        if (changes) {
          each(changes, function (_ref6) {
            var _ref7 = slicedToArray(_ref6, 2),
                path = _ref7[0],
                value = _ref7[1];

            set(newValues, path, value);
            set(newTouchedValues, path, path);
            changingValues.push(path);
          });
        }

        var newValidatedValues = function () {
          if (validatePaths) {
            var valuePathsList = arrayFrom(validatePaths);

            return mergeValidatedValuePaths(valuePathsList, validatedValues);
          } else {
            return validatedValues;
          }
        }();

        return _extends({}, this.state, {
          values: newValues,
          touchedValues: newTouchedValues,
          validatedValues: newValidatedValues,
          changingValues: changingValues
        });
      }
    }, {
      key: '_omitDeep',
      value: function _omitDeep(target, valueToOmit) {
        var _this11 = this;

        if (valueToOmit) {
          if (isPlainObject(target)) {

            return reduce(target, function (memo, value, key) {

              if (!isString(valueToOmit[key])) {
                memo[key] = _this11._omitDeep(value, valueToOmit[key]);
              }

              return memo;
            }, {});
          } else if (Array.isArray(target)) {

            return reduce(target, function (memo, value, index) {

              if (!isString(valueToOmit[index])) {
                memo.push(_this11._omitDeep(value, valueToOmit[index]));
              }

              return memo;
            }, []);
          } else {
            return target;
          }
        } else {
          return target;
        }
      }
    }, {
      key: '_getActiveErrors',
      value: function _getActiveErrors() {
        var _state4 = this.state,
            errors = _state4.errors,
            validateAllValues = _state4.validateAllValues,
            touchedValues = _state4.touchedValues,
            validatedValues = _state4.validatedValues;


        var externalErrors = get(this.props, externalErrorsPath || 'errors', {});
        var baseErrors = this._omitDeep(externalErrors, touchedValues);

        if (validateAllValues) {
          return defaultsDeep({}, errors, baseErrors);
        } else {
          return defaultsDeep(pickErrors(errors, validatedValues), baseErrors);
        }
      }
    }, {
      key: '_valuesWithDefaults',
      value: function _valuesWithDefaults(_ref8) {
        var _this12 = this;

        var values = _ref8.values,
            touchedValues = _ref8.touchedValues;


        if (only) {
          var validateableFields = arrayFrom(only);

          var propValues = reduce(validateableFields, function (memo, path) {
            var pathSegments = path.split(/[.[]/);

            /**
             * When using a complex or nested path for the 'only' option, we need
             * to copy the root object - not just the leaf node - to ensure attributes
             * in that root object that are not being validated, aren't omitted when
             * it comes time to (deeply) merge in the validated values
             */
            var pathRoot = pathSegments.length > 1 ? pathSegments[0] : path;

            var sourceValue = get(_this12.props, pathRoot);
            set(memo, pathRoot, sourceValue);

            return memo;
          }, {});

          var defaultValues = pickDeep(ValidatedComponent.defaultProps, validateableFields);

          var propsWithDefaults = defaultsDeep({}, propValues, defaultValues);

          return valuesWithDefaultsAndExemptions({
            defaultValue: propsWithDefaults,
            overrides: wrapObject(values),
            deepMergeExemptions: wrapObject(touchedValues)
          });
        } else {
          var _propsWithDefaults = defaultsDeep({}, this.props, ValidatedComponent.defaultProps);

          return valuesWithDefaultsAndExemptions({
            defaultValue: _propsWithDefaults,
            overrides: wrapObject(values),
            deepMergeExemptions: wrapObject(touchedValues)
          });
        }
      }
    }, {
      key: '_getCurrentValue',
      value: function _getCurrentValue(path) {
        return get(unwrapObject(this._valuesWithDefaults(this.state)), path);
      }
    }, {
      key: '_validate',
      value: function _validate(nextState, afterValidationCallback) {
        var _this13 = this;

        var afterValidationHandler = this._afterValidationHandler(nextState, afterValidationCallback);

        var valuesWithDefaults = unwrapObject(this._valuesWithDefaults(nextState));

        var validatorOptions = _extends({}, nextState, {
          valuesWithDefaults: valuesWithDefaults,
          touchedValues: pickOutermost(nextState.touchedValues),
          validatedValues: pickOutermost(nextState.validatedValues),
          props: _extends({}, this.props)
        });

        if (joiSchema) {
          Joi.validate(valuesWithDefaults, joiSchema, _extends({ abortEarly: false }, joiOptions), function (joiError) {
            var joiErrorList = joiError && joiError.details || [];

            var errors = reduce(joiErrorList, function (joiErrors, _ref9) {
              var message = _ref9.message,
                  path = _ref9.path;

              var messageWithFieldNameRemoved = message.replace(/^".+" /, '');

              set(joiErrors, path, messageWithFieldNameRemoved);

              return joiErrors;
            }, {});

            _this13._callValidatorIfDefined(arrayFrom(validator), _extends({}, validatorOptions, { errors: errors
            }), afterValidationHandler);
          });
        } else {
          this._callValidatorIfDefined(arrayFrom(validator), _extends({}, validatorOptions, { errors: {}
          }), afterValidationHandler);
        }
      }
    }, {
      key: '_callValidatorIfDefined',
      value: function _callValidatorIfDefined(validatorList, validatorOptions, afterValidatorHasRun) {
        var _this14 = this;

        if (validatorList.length > 0) {
          var callback = function () {
            if (validatorList.length > 1) {

              return function (_ref10) {
                var values = _ref10.values,
                    errors = _ref10.errors;


                _this14._callValidatorIfDefined(drop(validatorList), _extends({}, validatorOptions, { values: values, errors: errors
                }), afterValidatorHasRun);
              };
            } else {
              return afterValidatorHasRun;
            }
          }();

          validatorList[0](validatorOptions, callback);
        } else {
          var values = validatorOptions.values,
              errors = validatorOptions.errors;


          afterValidatorHasRun({ values: values, errors: errors });
        }
      }
    }, {
      key: '_afterValidationHandler',
      value: function _afterValidationHandler(nextState, afterValidationComplete) {
        var _this15 = this;

        return function (_ref11) {
          var errors = _ref11.errors,
              values = _ref11.values;


          var newState = _extends({}, nextState, { errors: errors, values: values
          });

          _this15.setState(newState, afterValidationComplete);
        };
      }
    }]);
    return ValidatorComponent;
  }(React.Component);

  return ValidatorComponent;
};

ReactJoiValidation.setJoi = function (joiClass) {
  Joi = joiClass;
};

ReactJoiValidation.setChangeHandlerStrategy = function (changeHandlerStrategy) {
  defaultChangeHandlerStrategy = changeHandlerStrategy;
};

exports.guessCorrectValue = guessCorrectValue;
exports.useEventTargetValue = useEventTargetValue;
exports.useFirstArgument = useFirstArgument;
exports.useSecondArgument = useSecondArgument;
exports.useThirdArgument = useThirdArgument;
exports.default = ReactJoiValidation;
